#############################################################
## !! WARNING!!!
#
#  These functions are shared between bash and zsh, don't
#  forget to test them in both shells.
#
#  If you need to do something specific for one or the other
#  move it in to either .profile (bash) or .zshrc (zsh).
#
#############################################################

#
# DEPS
###
function which {
    if ! /usr/bin/which $@
    then
        type $1 | head -1
    fi
}

function puts {
    if [[ $- =~ "i" ]]; then
        if [[ -z "$TMUX" ]]; then
            echo "$@"
        fi
    fi
}

function x {
  echo "+ $@"
  $@
}

# Show size of directory
function dume {
  du -h --max-depth=0 $1
}

# Keep zshrc prompt from hanging when ruby isn't installed
if [[ "$(which ruby)" = "ruby not found" ]]; then
  function ruby() {
    echo "n/a"
  }
fi

# Keep zshrc prompt from hanging when node isn't installed
if [[ "$(which node)" = "node not found" ]]; then
  if [[ "$(which nodejs)" = "nodejs not found" ]]; then
    function node() {
      echo "n/a"
    }
  else
    alias node="$(which nodejs)"
  fi
fi

#
# GLOBALS
###

VIM=$(/usr/bin/which vim 2> /dev/null)
GVIM=$(/usr/bin/which gvim 2> /dev/null)
test "$GVIM" || \
  GVIM=$(/usr/bin/which mvim 2> /dev/null)

###

function tm() {
    if [[ "$1" = "mine" || "$1" = "takeover" ]]; then
        tmux detach -a
        return $?
    fi

    if [[ "$1" = "killall" || "$1" = "kill" ]]; then
        tmux ls | grep : | cut -d. -f1 | awk '{print substr($1, 0, length($1)-1)}' | xargs kill
        return $?
    fi

    tmux attach-session || (cd ~/; tmux )
}

#############################################################
# VirtualBox Fuctions
#############################################################
_vb_cmd="VBoxManage"
if test "$(which $_vb_cmd 2> /dev/null)"; then
  function _vb_help {
    echo "Usage: vb ACTION VM"
    echo " "
    echo "Actions"
    echo "- up|start          start/restart/wake"
    echo "- pause             pause"
    echo "- sleep             sleep"
    echo "- down|stop         graceful shutdown"
    echo "- kill|halt|off     forceful shutdown"
    echo "- status|state      minimial status "
    echo "- info|describe     verbose status "
    echo "- debug|setup       start with gui for setup or troubleshooting"
    echo "- ssh               attempt to ssh to guest vbox (fragile)"
    echo "- forward VM FROM [TO]"
    echo "                    add port forward"
    echo "- ports             list forwarded ports"
    echo "- fix               run network fix"
    echo "- help              show this message "
    echo " "
    echo "VMs"
    echo "$($_vb_cmd list vms| grep -v boot2docker-vm)"
    echo " "
  }

  function _vm_net_fix {
    local _iface="$(VBoxManage showvminfo $1 --machinereadable | grep hostonlyadapter | cut -d '"' -f 2)"
    local _block="$(ifconfig | grep "inet.*\.255" | grep -v ".1.255" | awk '{print $NF}' | sed 's/\.255//')"
    echo "++ sudo route -n add -net ${_block}.0/24 -interface ${_iface}"

    sudo route -n add -net ${_block}.0/24 -interface ${_iface}
  }


  function vb {
    if ! test "$(which $_vb_cmd)"; then
      echo "ERROR: VirtualBox not found"
      echo " "
      _vb_help
      return 1
    fi

    if [[ "$1" = "" || "$1" = "help" ]]; then
      _vb_help
      return 0
    fi

    local guest=$2
    # I am setting a default here for myself, you might want to remove this if
    # you're not me.
    test "$guest" || guest=Debian

    # Error checking for those that remove the default guest lines above.
    if ! test "$guest"; then
      echo "ERROR: VirtualBox VM required"
      echo " "
      _vb_help
      return 1
    fi

    case $1 in
    up|start)
      $_vb_cmd controlvm $guest resume || $_vb_cmd startvm $guest --type headless;;
    debug|setup)
      $_vb_cmd startvm $guest --type gui;;
    down|stop)
      $_vb_cmd controlvm $guest acpipowerbutton;;
    pause)
      $_vb_cmd controlvm $guest pause;;
    sleep)
      $_vb_cmd controlvm $guest acpisleepbutton;;
    kill|halt|off)
      $_vb_cmd controlvm $guest poweroff;;
    status|state)
      $_vb_cmd showvminfo $guest | grep State;;
    info|describe)
      $_vb_cmd showvminfo $guest | less;;
    fix|fuck)
      _vm_net_fix $guest;;
    ports)
      $_vb_cmd showvminfo $guest | grep Rule | awk -F',' '{print $1" "$4}' | awk '{str = sprintf("%-10s %s",$6,$NF); print str}';;
    forward)
      local _from=$3
      local _to=$4
      if ! test "$_from"; then
        _vb_help
        return 1
      fi
      test "$_to" || _to=$_from
      $_vb_cmd modifyvm $guest --natpf1 ",tcp,,$_from,,$_to";;
    ssh)
      # Fragile at best
      #
      # I setup port forwarding with this to get this working:
      #
      # $ VBoxManage modifyvm GuestBox --natpf1 "ssh,tcp,,2222,,22"
      #
      # USER=guestuser vb ssh GuestBox
      #_vm_net_fix $guest
      test "$USER" || USER=`whoami`
      ssh $USER@localhost -p $(VBoxManage showvminfo $guest | grep Rule | grep ssh | awk -F',' '{print $4}' | awk -F'=' '{ print $NF}');;
    *)
      _vb_help
    esac
  }
  #alias vm=vb
  puts "+ initialized vb function"
fi

_pl_cmd="prlctl"
if test "$(which $_pl_cmd 2> /dev/null)"; then
  function _pl_help {
    echo "Usage: pl|vm ACTION VM"
    echo " "
    echo "Actions"
    echo "- list"
    echo "- start"
    echo "- resume"
    echo "- stop"
    echo "- pause"
    echo "- kill"
    echo "- status"
    echo "- info"
    echo "- ssh     ssh in to host via shared interface"
    echo "- enter   enter host as root via Parallels"
    echo "- addr    show shared ip address"
    echo "- iface   show shared interface"
    echo "- help    show this message "
    echo " "
    echo "VMs"
    echo "$($_pl_cmd list)"
    echo " "
  }

  function _pl_net_fix {
    local _iface="$(VBoxManage showvminfo $1 --machinereadable | grep hostonlyadapter | cut -d '"' -f 2)"
    local _block="$(ifconfig | grep "inet.*\.255" | grep -v ".1.255" | awk '{print $NF}' | sed 's/\.255//')"
    echo "++ sudo route -n add -net ${_block}.0/24 -interface ${_iface}"

    sudo route -n add -net ${_block}.0/24 -interface ${_iface}
  }

  function pl {
    if ! test "$(which $_pl_cmd)"; then
      echo "ERROR: VirtualBox not found"
      echo " "
      _pl_help
      return 1
    fi

    if [[ "$1" = "" || "$1" = "help" ]]; then
      _pl_help
      return 0
    fi

    local guest=$2
    # I am setting a default here for myself, you might want to remove this if
    # you're not me.
    test "$guest" || guest=Debian

    # Error checking for those that remove the default guest lines above.
    if ! test "$guest"; then
      echo "ERROR: VirtualBox VM required"
      echo " "
      _pl_help
      return 1
    fi

    case $1 in
    list)
      $_pl_cmd list --all;;
    start)
      $_pl_cmd start $guest;;
    restart)
      $_pl_cmd restart $guest;;
    resume)
      $_pl_cmd resume $guest;;
    stop)
      $_pl_cmd stop $guest;;
    pause)
      $_pl_cmd pause $guest;;
    sleep)
      $_pl_cmd sleep $guest;;
    kill)
      $_pl_cmd stop $guest --kill;;
    status)
      $_pl_cmd status $guest;;
    info)
      $_pl_cmd list -i $guest | less;;
    iface)
      $_pl_cmd list -i $guest | grep "shared" | awk '{print $1}' | sed 's/net/eth/';;
    enter)
      $_pl_cmd enter $guest;;
    addr)
      $_pl_cmd exec $guest ifconfig $(pl iface) | grep 'inet addr' | awk '{print $2}' | awk -F':' '{print $NF}';;
    hosts)
      sudo bash -c "echo -e \"`cat /private/etc/hosts | grep -v "$guest\."`\n`pl addr $guest` $guest debian.localhost.com vm.localhost.com debian vm\n\" > /private/etc/hosts"
      sudo dscacheutil -flushcache;;
    fix)
      # only works for linux guests
      if ! ping -c 1 -t 5 $guest > /dev/null; then
        $_pl_cmd exec $guest /etc/init.d/networking restart
      fi;;
    ping)
      ping -c 1 $guest;;
    ssh)
      if ! ping -c 1 -t 2 $guest > /dev/null; then
        pl fix $guest
      fi
      test "$USER" || USER=`whoami`
      test "`cat /private/etc/hosts | grep $guest`" || pl hosts $guest
      ssh $USER@$guest;;
    *)
      _pl_help
    esac
  }
  alias vm=pl
  puts "+ initialized pl function"
  puts "+    alias: 'vm'"
  puts "+ Usage: vm ACTION VM"
fi

#############################################################
# Encryption Fuctions
#############################################################
#
function decrypt {
        # decrypt if selected
        FILE=$1
        echo "-> decrypt: $(basename $FILE) "
        openssl enc -d -aes-256-cbc -salt -in "$FILE" -out "${FILE/.enc/}"
        FILE=""
}

function encrypt {
        # encrypt if selected
        FILE=$1
        echo "-> encrypt: $(basename $FILE) "
        openssl enc -e -aes-256-cbc -salt -in "$FILE" -out "$FILE.enc"
        FILE=""
}

#############################################################
# Function - quickly add strings to root .gitignore
#############################################################
#
function gitignore {
    echo "$1" >> $HOME/.gitignore
}

function git_clean {
  echo "DEPRICATED: use 'git latest'"
  x git pull
  x git fetch -p
  x git remote prune origin
}

function git_clean_force {
  local _branch="$1"
  [[ -z $_branch ]] && _branch=master

  x git fetch -p
  x git remote prune origin

  echo "git branch --merged | grep -v "\*" | grep -v "$_branch" | grep -v dev | xargs -n 1 git branch -d"
  git branch --merged | grep -v "\*" | grep -v "$_branch" | grep -v dev | xargs -n 1 git branch -d
}


#############################################################
# Function - Finding files and directories
#############################################################
#
function ff() {
        find . -type f -name "*$1*"
}

function fd() {
        find . -type d -name "*$1*"
}

#############################################################
# SSH Agent Setup
#############################################################
#
SSH_ENV="$HOME/.ssh/environment"

function start_agent {
  echo "Initialising new SSH agent..."
  /usr/bin/ssh-agent | sed 's/^echo/#echo/' > "${SSH_ENV}"
  echo succeeded
  chmod 600 "${SSH_ENV}"
  . "${SSH_ENV}" > /dev/null

  for k in $(find ~/.ssh -type f -name "*_rsa"); do
    echo "Adding $k"
    /usr/bin/ssh-add $k
  done
}

# Source SSH settings, if applicable
if [ -f "${SSH_ENV}" ]; then
     . "${SSH_ENV}" > /dev/null
     ps -ef | grep ${SSH_AGENT_PID} | grep ssh-agent$ > /dev/null || {
         start_agent;
     }
else
     start_agent;
fi

function sgvim() {
  $GVIM -f "sudo:$@"
}

function svim() {
  $VIM -f "sudo:$@"
}

function gvim() {
  $GVIM -X "$@" &
}

function gvimdiff() {
  ${GVIM}diff -X "$@" &
}

function npm_exec() {
  PATH=$(npm bin):$PATH $@
}

#############################################################
# Function -- find wrapper
#############################################################
function find {
    if [ `uname -s` = "Darwin" ]; then
        browser="open"
    fi
    test "$browser" || browser=`which chromium-browser 2> /dev/null`
    test "$browser" || browser=`which google-chrome 2> /dev/null`
    test "$browser" || browser=`which firefox 2> /dev/null`
    query="`echo "$@" | sed -e 's:^[a-z\/\~\.]* ::' -e 's/-type [mg]//' -e 's/-name//'`"
    if [[ $@ =~ "-type m" ]]; then
        $browser "http://maps.google.com/?q=$query" 2>&1 > /dev/null &
    elif [[ $@ =~ "-type g" ]]; then
        $browser "http://www.google.com/search?q=$query" 2>&1 > /dev/null &
    else
        /usr/bin/find $@
    fi
}
puts "+ initialized find function"
puts "+ -type m :: google maps"
puts "+ -type g :: google search"

#############################################################
# Function -- myip
#############################################################
function myip {
    # When IP isn't found, use hostname.
    # This will pretty much always break though.
    if [[ "$(uname)" = "Darwin" ]]; then
        for en in en2 en1 en0; do
            ipaddr=$(ifconfig $en | grep "inet " | awk '{ print $2 }')
            if test "$ipaddr"; then
              echo $ipaddr
              return 0
            fi
        done
    else
        for eth in eth2 eth1 eth0; do
            ipaddr=$(ifconfig $eth | grep "inet " | awk '{ print $2 }')
            if test "$ipaddr"; then
                echo $ipaddr
                return 0
            fi
        done
    fi
    echo "$(hostname)"
}
puts "+ initialized myip function"

#############################################################
# Function -- PSSH wrapper
#############################################################
if test "$(which pssh 2> /dev/null)"; then
    pssh_exec=$(/usr/bin/which pssh)
    # wrapper (via ssh-agent)
    function pssh() {
      cmd="$@"
      if ! test -f hosts; then
        echo "pssh: 'hosts' file not found"
        return 1
      fi
      $pssh_exec --par=10 --hosts=./hosts -l $USER \
        -O UserKnownHostsFile=/dev/null -O StrictHostKeyChecking=no "$@"
    }

    function psshi() {
      cmd="$@"
      if ! test -f hosts; then
        echo "pssh: 'hosts' file not found"
        return 1
      fi
      $pssh_exec -i --par=10 --hosts=./hosts -l $USER \
        -O UserKnownHostsFile=/dev/null -O StrictHostKeyChecking=no "$@"
    }

    # wrapper w/ password request
    function ppssh() {
      cmd="$@"
      if ! test -f hosts; then
        echo "pssh: 'hosts' file not found"
        return 1
      fi
      $pssh_exec --par=10 --hosts=./hosts -l $USER -A \
        -O UserKnownHostsFile=/dev/null -O StrictHostKeyChecking=no "$@"
    }

    # pass thru
    function pssh!() {
      $pssh_exec -O UserKnownHostsFile=/dev/null -O StrictHostKeyChecking=no $@
    }

    puts "+ initialized pssh functions"
    puts "+ - pssh  :: pssh with './hosts'"
    puts "+ - ppssh :: pssh with './hosts' and password request"
    puts "+ - pssh! :: pssh pass through"
else
    echo "X install pssh with 'pip install pssh'"
fi

if test "$(which pscp 2> /dev/null)"; then
    pscp_exec=$(/usr/bin/which  pscp)
    # wrapper (via ssh-agent)
    function pscp() {
      cmd="$@"
      if ! test -f hosts; then
        echo "pscp: 'hosts' file not found"
        return 1
      fi
      $pscp_exec --par=10 --hosts=./hosts -l $USER \
        -O UserKnownHostsFile=/dev/null -O StrictHostKeyChecking=no "$@"
    }

    # wrapper w/ password request
    function ppscp() {
      cmd="$@"
      if ! test -f hosts; then
        echo "pscp: 'hosts' file not found"
        return 1
      fi
      $pscp_exec --par=10 --hosts=./hosts -l $USER -A \
        -O UserKnownHostsFile=/dev/null -O StrictHostKeyChecking=no "$@"
    }

    # pass thru
    function pscp!() {
      $pscp_exec -O UserKnownHostsFile=/dev/null -O StrictHostKeyChecking=no $@
    }

    puts "+ initialized pscp functions"
    puts "+ - pscp  :: pscp with './hosts'"
    puts "+ - ppscp :: pscp with './hosts' and password request"
    puts "+ - pscp! :: pscp pass through"
fi

#############################################################
# Function -- Docker Flatten
#############################################################
if test "$(which docker 2> /dev/null)"; then
    function docker_flatten() {
        echo "got: $@"
        image_name=$(echo $1 | awk -F':' '{print $1}')
        image_tag=$(echo $1  | awk -F':' '{print $2}')
        test "$image_name" || return 1
        test "$image_tag"  || image_tag="latest"

        docker run --name $image_name $image_name:$image_tag && \
          (docker export $image_name | docker import - $image_name:${image_tag}_flat) && \
            docker rm $image_name

        puts "+ initialized docker_flatten function"
        puts "+   usage: docker_flatten <image>[:<tag>]"
    }
fi

function docker_clean {
  echo "+ clean containers"
  docker ps -a | grep -v 'NAMES' | grep -v 'Up ' | awk '{ print $NF }' | xargs docker rm

  echo "+ clean images"
  docker images | grep '^<none>' | awk '{ print $3 }' | xargs docker rmi
}

function docker_killall {
  echo "+ killing all containers"
  docker ps | awk '{print $NF}' | grep -v 'NAMES' | xargs docker kill
}

function docker_stopall {
  echo "+ stopping all containers"
  docker ps | awk '{print $NF}' | grep -v 'NAMES' | xargs docker stop
}

docker_exec="$(which docker)"

#############################################################
# Function -- Boot2Docker
#############################################################
if test "$(which boot2docker 2> /dev/null)"; then
    function docker_shellinit {
      local _shellinit="$(boot2docker shellinit)"
      eval "$(echo ${_shellinit})"
      echo "${_shellinit}" > ~/.boot2dockerrc
    }

    function docker_reup {
      echo "+ running vpn fix"
      docker_down

      echo "+ resetting vbox route"

      local _iface="$(VBoxManage showvminfo boot2docker-vm --machinereadable | grep hostonlyadapter | cut -d '"' -f 2)"
      echo "++ sudo route -n add -net 192.168.59.0/24 -interface ${_iface}"

      sudo route -n add -net 192.168.59.0/24 -interface ${_iface} && \
        docker_up
    }

    function docker_reset {
      echo "+ clearing docker variables"
      unset DOCKER_HOST
      unset DOCKER_CERT_PATH
      unset DOCKER_TLS_VERIFY
      docker_shellinit
    }

    function docker_up {
      echo "+ starting boot2docker"
      boot2docker up
      b2dSTATUS=$?
      docker_reset
      return $b2dSTATUS
    }

    function docker_down {
      echo "+ stopping boot2docker"
      boot2docker down
      return 0
    }

    function b2d {
      case "$@" in
      reload)
        docker_reset
        return 0;;
      reset|fix|reup|fuck)
        docker_reup
        return $?;;
      up)
        docker_up
        return $?;;
      down)
        docker_down
        return $?;;
      clean)
        docker_clean
        return $?;;
      esac
      boot2docker $@
    }

    function docker {
      case "$@" in
      reload)
        docker_reset
        return 0;;
      reset|fix|reup|fuck)
        docker_reup
        return $?;;
      up)
        docker_up
        return $?;;
      down)
        docker_down
        return $?;;
      clean)
        docker_clean
        return $?;;
      stopall)
        docker_stopall
        return $?;;
      killall)
        docker_killall
        return $?;;
      esac
      $docker_exec $@
    }

    puts "+ initialized boot2docker/docker functions"
    puts "+   usage: b2d|docker [up|down|reup|clean|reset]"
else
    function docker {
      case "$@" in
      clean)
        docker_clean
        return 0;;
      stopall)
        docker_stopall
        return $?;;
      killall)
        docker_killall
        return $?;;
      esac
      $docker_exec $@
    }

fi

# tmate
function tmate {
  local _sock=/tmp/tmate.sock
  local _tmate=/usr/local/bin/tmate

  if [ -z "$@" ]; then
    $_tmate -S $_sock
  else
    case $@ in
    p|print|ssh|url)
      $_tmate -S $_sock display -p '#{tmate_ssh}';;
    ro|printro|sshro|rourl|urlro|rossh)
      $_tmate -S $_sock display -p '#{tmate_ssh_ro}';;
    *)
      $_tmate -S $_sock
    esac
  fi
}

# Create a new directory and enter it
function mkd() {
    mkdir -p "$@" && cd "$@"
}

# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
function tre() {
    tree -aC -I '.git' --dirsfirst "$@" | less -FRNX
}

# Get colors in manual pages
function man() {
    env \
        LESS_TERMCAP_mb=$(printf "\e[1;31m") \
        LESS_TERMCAP_md=$(printf "\e[1;31m") \
        LESS_TERMCAP_me=$(printf "\e[0m") \
        LESS_TERMCAP_se=$(printf "\e[0m") \
        LESS_TERMCAP_so=$(printf "\e[1;44;33m") \
        LESS_TERMCAP_ue=$(printf "\e[0m") \
        LESS_TERMCAP_us=$(printf "\e[1;32m") \
        man "$@"
}

function godev() {
  local devpath="${HOME}/Development"

  if [[ -z $1 ]]; then
    cd "$devpath"
    return
  fi

  local _found="$(/usr/bin/find "${devpath}" -maxdepth 1 -type d -iname "*$1*" | xargs | awk '{print $1}')"

  if [[ -z $_found ]]; then
    cd "$devpath"
    echo "Could not find a directory name containing \"$1\" in:"
    echo "$(ls -lF | grep '^d' | awk '{print $NF}' |sed 's/\///' | xargs)"
    return 1
  fi

  cd "$_found"
}
alias Dev="godev"
alias dev="godev"
alias God="godev"
alias god="godev"

# go to a folder easily in your gopath
function gogo(){
    local d=$1
    local gopath=$(go env GOPATH)/src

    if [[ -z $d ]]; then
        echo "Warning: no project specified attempting to find go:gh/user"
        x cd "$gopath/github.com/`whoami`"
        return $?
    fi

    # check for my packages first...
    local _mine="$(/usr/bin/find "${gopath}" -iname "*$d*" -type d | grep -v "Godeps" | grep "${USER}\/*$d*" | sort | xargs | awk '{print $1}')"
    if [[ ! -z $_mine ]]; then
      cd "$_mine"
      return
    fi

    # check for others second...
    local _path="$(/usr/bin/find "${gopath}" -iname "*$d*" -type d | grep -v "Godeps" | xargs | awk '{print $1}')"
    if [[ -z $_path ]]; then
        echo "Could not find a directory containing \"*$d*\" in ${gopath}/..."
        echo "Maybe you need to 'go get' it ;)"
        return 1
    fi

    cd "$_path"
}

function gogit {
  local substr="$(echo $1 | awk -F'/' '{print $NF}' | awk -F'.' '{print $1}')"
  if ! godev $substr; then
    x git clone $1
    godev $substr
  fi
}

## Noop Server - Clean http listener
function listen {
  local port="$1"
  local addr="$2"

  [[ -z $port ]] && port=3000
  [[ -z $addr ]] && addr=0.0.0.0

  x docker run --rm -it -p "$port:$port" -e PORT=$port -e ADDR=$addr jmervine/noop-server
}

## fix up docker generated files
function own {
  local _path="$1"
  [[ -z $_path ]] && _path="."

  find $_path -user root | xargs sudo chown jmervine:
}

# because some systems need this in /etc/bashrc
function shopt {
  bash -lc "shopt $@"
}

function icdep {
# usages for full deploy:
# $ icdep clone watchtower-tng 1.0.0
# $ icdep pull watchtower-tng 1.0.0
# $ icdep deploy watchtower-tng 1.0.0

  local action=$1
  local app=$2
  local tag=$3
  local user=$4
  local usage="icdep ACTION APP TAG|BRANCH [USER]"

  if [ -z $action ] || [ -z $app ] || [ -z $tag ]; then
    echo $usage
    return 1
  fi

  [[ -z $user ]] && user=`whoami`

  if [ "$action" = "clone" ]; then
    ion-client run -a deploymaster bin/$action -c $app -b $tag
    return $?
  fi

  ion-client run -a deploymaster bin/$action -c $app -b $tag -u $user
  return $?
}

# vim: ft=sh:
