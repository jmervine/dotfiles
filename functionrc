#############################################################
## !! WARNING!!!
#
#  These functions are shared between bash and zsh, don't
#  forget to test them in both shells.
#
#  If you need to do something specific for one or the other
#  move it in to either .profile (bash) or .zshrc (zsh).
#
#############################################################

#
# DEPS
###
function which {
    if ! /usr/bin/which $@
    then
        type $1 | head -1
    fi
}

function puts {
    if [[ $- =~ "i" ]]; then
        if [[ -z "$TMUX" ]]; then
            echo "$@"
        fi
    fi
}

function x {
  echo "+ $@"
  $@
}

# Keep zshrc prompt from hanging when ruby isn't installed
if [[ "$(which ruby)" = "ruby not found" ]]; then
  function ruby() {
    echo "n/a"
  }
fi

# Keep zshrc prompt from hanging when node isn't installed
if [[ "$(which node)" = "node not found" ]]; then
  function node() {
    echo "n/a"
  }
fi

#
# GLOBALS
###

VIM=$(/usr/bin/which vim 2> /dev/null)
GVIM=$(/usr/bin/which gvim 2> /dev/null)
test "$GVIM" || \
  GVIM=$(/usr/bin/which mvim 2> /dev/null)

###

function tm() {
    if [[ "$1" = "mine" || "$1" = "takeover" ]]; then
        tmux detach -a
        return $?
    fi

    if [[ "$1" = "killall" || "$1" = "kill" ]]; then
        tmux ls | grep : | cut -d. -f1 | awk '{print substr($1, 0, length($1)-1)}' | xargs kill
        return $?
    fi

    tmux attach-session || (cd ~/; tmux )
}

#############################################################
# VirtualBox Fuctions
#############################################################
_vb_cmd="VBoxManage"
if test "$(which $_vb_cmd 2> /dev/null)"; then
  function _vb_help {
    echo "Usage: vb ACTION VM"
    echo " "
    echo "Actions"
    echo "- up|start          start/restart/wake"
    echo "- pause             pause"
    echo "- sleep             sleep"
    echo "- down|stop         graceful shutdown"
    echo "- kill|halt|off     forceful shutdown"
    echo "- status|state      minimial status "
    echo "- info|describe     verbose status "
    echo "- debug|setup       start with gui for setup or troubleshooting"
    echo "- ssh               attempt to ssh to guest vbox (fragile)"
    echo "- forward VM FROM [TO]"
    echo "                    add port forward"
    echo "- ports             list forwarded ports"
    echo "- fix               run network fix"
    echo "- help              show this message "
    echo " "
    echo "VMs"
    echo "$($_vb_cmd list vms| grep -v boot2docker-vm)"
    echo " "
  }

  function _vm_net_fix {
    local _iface="$(VBoxManage showvminfo $1 --machinereadable | grep hostonlyadapter | cut -d '"' -f 2)"
    local _block="$(ifconfig | grep "inet.*\.255" | grep -v ".1.255" | awk '{print $NF}' | sed 's/\.255//')"
    echo "++ sudo route -n add -net ${_block}.0/24 -interface ${_iface}"

    sudo route -n add -net ${_block}.0/24 -interface ${_iface}
  }


  function vb {
    if ! test "$(which $_vb_cmd)"; then
      echo "ERROR: VirtualBox not found"
      echo " "
      _vb_help
      return 1
    fi

    if [[ "$1" = "" || "$1" = "help" ]]; then
      _vb_help
      return 0
    fi

    local guest=$2
    # I am setting a default here for myself, you might want to remove this if
    # you're not me.
    test "$guest" || guest=Debian

    # Error checking for those that remove the default guest lines above.
    if ! test "$guest"; then
      echo "ERROR: VirtualBox VM required"
      echo " "
      _vb_help
      return 1
    fi

    case $1 in
    up|start)
      $_vb_cmd controlvm $guest resume || $_vb_cmd startvm $guest --type headless;;
    debug|setup)
      $_vb_cmd startvm $guest --type gui;;
    down|stop)
      $_vb_cmd controlvm $guest acpipowerbutton;;
    pause)
      $_vb_cmd controlvm $guest pause;;
    sleep)
      $_vb_cmd controlvm $guest acpisleepbutton;;
    kill|halt|off)
      $_vb_cmd controlvm $guest poweroff;;
    status|state)
      $_vb_cmd showvminfo $guest | grep State;;
    info|describe)
      $_vb_cmd showvminfo $guest | less;;
    fix|fuck)
      _vm_net_fix $guest;;
    ports)
      $_vb_cmd showvminfo $guest | grep Rule | awk -F',' '{print $1" "$4}' | awk '{str = sprintf("%-10s %s",$6,$NF); print str}';;
    forward)
      local _from=$3
      local _to=$4
      if ! test "$_from"; then
        _vb_help
        return 1
      fi
      test "$_to" || _to=$_from
      $_vb_cmd modifyvm $guest --natpf1 ",tcp,,$_from,,$_to";;
    ssh)
      # Fragile at best
      #
      # I setup port forwarding with this to get this working:
      #
      # $ VBoxManage modifyvm GuestBox --natpf1 "ssh,tcp,,2222,,22"
      #
      # USER=guestuser vb ssh GuestBox
      _vm_net_fix $guest
      test "$USER" || USER=`whoami`
      ssh $USER@localhost -p $(VBoxManage showvminfo $guest | grep Rule | grep ssh | awk -F',' '{print $4}' | awk -F'=' '{ print $NF}');;
    *)
      _vb_help
    esac
  }
  alias vm=vb
  puts "+ initialized vb function"
  puts "+    alias: 'vm'"
  puts "+ Usage: vm ACTION VM"
fi

#############################################################
# Encryption Fuctions
#############################################################
#
function decrypt {
        # decrypt if selected
        FILE=$1
        echo "-> decrypt: $(basename $FILE) "
        openssl enc -d -aes-256-cbc -salt -in "$FILE" -out "${FILE/.enc/}"
        FILE=""
}

function encrypt {
        # encrypt if selected
        FILE=$1
        echo "-> encrypt: $(basename $FILE) "
        openssl enc -e -aes-256-cbc -salt -in "$FILE" -out "$FILE.enc"
        FILE=""
}

#############################################################
# Function - quickly add strings to root .gitignore
#############################################################
#
function gitignore {
    echo "$1" >> $HOME/.gitignore
}


#############################################################
# Function - Finding files and directories
#############################################################
#
function ff() {
        find . -type f -name "*$1*"
}

function fd() {
        find . -type d -name "*$1*"
}

#############################################################
# SSH Agent Setup
#############################################################
#
SSH_ENV="$HOME/.ssh/environment"

function start_agent {
     echo "Initialising new SSH agent..."
     /usr/bin/ssh-agent | sed 's/^echo/#echo/' > "${SSH_ENV}"
     echo succeeded
     chmod 600 "${SSH_ENV}"
     . "${SSH_ENV}" > /dev/null
     /usr/bin/ssh-add;
}

# Source SSH settings, if applicable
if [ -f "${SSH_ENV}" ]; then
     . "${SSH_ENV}" > /dev/null
     ps -ef | grep ${SSH_AGENT_PID} | grep ssh-agent$ > /dev/null || {
         start_agent;
     }
else
     start_agent;
fi

function sgvim() {
  $GVIM -f "sudo:$@"
}

function svim() {
  $VIM -f "sudo:$@"
}

function gvim() {
  $GVIM -X "$@" &
}

function gvimdiff() {
  ${GVIM}diff -X "$@" &
}

function npm_exec() {
  PATH=$(npm bin):$PATH $@
}

#############################################################
# Function -- find wrapper
#############################################################
function find {
    if [ `uname -s` = "Darwin" ]; then
        browser="open"
    fi
    test "$browser" || browser=`which chromium-browser 2> /dev/null`
    test "$browser" || browser=`which google-chrome 2> /dev/null`
    test "$browser" || browser=`which firefox 2> /dev/null`
    query="`echo "$@" | sed -e 's:^[a-z\/\~\.]* ::' -e 's/-type [mg]//' -e 's/-name//'`"
    if [[ $@ =~ "-type m" ]]; then
        $browser "http://maps.google.com/?q=$query" 2>&1 > /dev/null &
    elif [[ $@ =~ "-type g" ]]; then
        $browser "http://www.google.com/search?q=$query" 2>&1 > /dev/null &
    else
        /usr/bin/find $@
    fi
}
puts "+ initialized find function"
puts "+ -type m :: google maps"
puts "+ -type g :: google search"

#############################################################
# Function -- myip
#############################################################
function myip {
    # When IP isn't found, use hostname.
    # This will pretty much always break though.
    if [[ "$(uname)" = "Darwin" ]]; then
        for en in en2 en1 en0; do
            ipaddr=$(ifconfig $en | grep "inet " | awk '{ print $2 }')
            if test "$ipaddr"; then
              echo $ipaddr
              return 0
            fi
        done
    else
        for eth in eth2 eth1 eth0; do
            ipaddr=$(ifconfig $eth | grep "inet " | awk '{ print $2 }')
            if test "$ipaddr"; then
                echo $ipaddr
                return 0
            fi
        done
    fi
    echo "$(hostname)"
}
puts "+ initialized myip function"

#############################################################
# Function -- PSSH wrapper
#############################################################
if test "$(which pssh 2> /dev/null)"; then
    pssh_exec=$(/usr/bin/which pssh)
    # wrapper (via ssh-agent)
    function pssh() {
      cmd="$@"
      if ! test -f hosts; then
        echo "pssh: 'hosts' file not found"
        return 1
      fi
      $pssh_exec --par=10 --hosts=./hosts -l $USER \
        -O UserKnownHostsFile=/dev/null -O StrictHostKeyChecking=no "$@"
    }

    function psshi() {
      cmd="$@"
      if ! test -f hosts; then
        echo "pssh: 'hosts' file not found"
        return 1
      fi
      $pssh_exec -i --par=10 --hosts=./hosts -l $USER \
        -O UserKnownHostsFile=/dev/null -O StrictHostKeyChecking=no "$@"
    }

    # wrapper w/ password request
    function ppssh() {
      cmd="$@"
      if ! test -f hosts; then
        echo "pssh: 'hosts' file not found"
        return 1
      fi
      $pssh_exec --par=10 --hosts=./hosts -l $USER -A \
        -O UserKnownHostsFile=/dev/null -O StrictHostKeyChecking=no "$@"
    }

    # pass thru
    function pssh!() {
      $pssh_exec -O UserKnownHostsFile=/dev/null -O StrictHostKeyChecking=no $@
    }

    puts "+ initialized pssh functions"
    puts "+ - pssh  :: pssh with './hosts'"
    puts "+ - ppssh :: pssh with './hosts' and password request"
    puts "+ - pssh! :: pssh pass through"
else
    echo "X install pssh with 'pip install pssh'"
fi

if test "$(which pscp 2> /dev/null)"; then
    pscp_exec=$(/usr/bin/which  pscp)
    # wrapper (via ssh-agent)
    function pscp() {
      cmd="$@"
      if ! test -f hosts; then
        echo "pscp: 'hosts' file not found"
        return 1
      fi
      $pscp_exec --par=10 --hosts=./hosts -l $USER \
        -O UserKnownHostsFile=/dev/null -O StrictHostKeyChecking=no "$@"
    }

    # wrapper w/ password request
    function ppscp() {
      cmd="$@"
      if ! test -f hosts; then
        echo "pscp: 'hosts' file not found"
        return 1
      fi
      $pscp_exec --par=10 --hosts=./hosts -l $USER -A \
        -O UserKnownHostsFile=/dev/null -O StrictHostKeyChecking=no "$@"
    }

    # pass thru
    function pscp!() {
      $pscp_exec -O UserKnownHostsFile=/dev/null -O StrictHostKeyChecking=no $@
    }

    puts "+ initialized pscp functions"
    puts "+ - pscp  :: pscp with './hosts'"
    puts "+ - ppscp :: pscp with './hosts' and password request"
    puts "+ - pscp! :: pscp pass through"
fi

#############################################################
# Function -- Docker Flatten
#############################################################
if test "$(which docker 2> /dev/null)"; then
    function docker_flatten() {
        echo "got: $@"
        image_name=$(echo $1 | awk -F':' '{print $1}')
        image_tag=$(echo $1  | awk -F':' '{print $2}')
        test "$image_name" || return 1
        test "$image_tag"  || image_tag="latest"

        docker run --name $image_name $image_name:$image_tag && \
          (docker export $image_name | docker import - $image_name:${image_tag}_flat) && \
            docker rm $image_name

        puts "+ initialized docker_flatten function"
        puts "+   usage: docker_flatten <image>[:<tag>]"
    }
fi

#############################################################
# Function -- Boot2Docker
#############################################################
if test "$(which boot2docker 2> /dev/null)"; then
    function docker_shellinit {
      local _shellinit="$(boot2docker shellinit)"
      eval "$(echo ${_shellinit})"
      echo "${_shellinit}" > ~/.boot2dockerrc
    }

    function docker_reup {
      echo "+ running vpn fix"
      docker_down

      echo "+ resetting vbox route"

      local _iface="$(VBoxManage showvminfo boot2docker-vm --machinereadable | grep hostonlyadapter | cut -d '"' -f 2)"
      echo "++ sudo route -n add -net 192.168.59.0/24 -interface ${_iface}"

      sudo route -n add -net 192.168.59.0/24 -interface ${_iface} && \
        docker_up
    }

    function docker_reset {
      echo "+ clearing docker variables"
      unset DOCKER_HOST
      unset DOCKER_CERT_PATH
      unset DOCKER_TLS_VERIFY
      docker_shellinit
    }

    function docker_up {
      echo "+ starting boot2docker"
      boot2docker up
      b2dSTATUS=$?
      docker_reset
      return $b2dSTATUS
    }

    function docker_down {
      echo "+ stopping boot2docker"
      boot2docker down
      return 0
    }

    function docker_clean {
      echo "+ clean containers"
      docker ps -a | grep -v 'NAMES' | grep -v 'Up ' | awk '{ print $NF }' | xargs docker rm

      echo "+ clean images"
      docker images | grep '^<none>' | awk '{ print $3 }' | xargs docker rmi
    }

    function b2d {
      case "$@" in
      reload)
        docker_reset
        return 0;;
      reset|fix|reup|fuck)
        docker_reup
        return $?;;
      up)
        docker_up
        return $?;;
      down)
        docker_down
        return $?;;
      clean)
        docker_clean
        return $?;;
      esac
      boot2docker $@
    }

    docker_exec="$(which docker)"
    function docker {
      case "$@" in
      reload)
        docker_reset
        return 0;;
      reset|fix|reup|fuck)
        docker_reup
        return $?;;
      up)
        docker_up
        return $?;;
      down)
        docker_down
        return $?;;
      clean)
        docker_clean
        return $?;;
      esac
      $docker_exec $@
    }

    puts "+ initialized boot2docker/docker functions"
    puts "+   usage: b2d|docker [up|down|reup|clean|reset]"
fi

# tmate
function tmate {
  local _sock=/tmp/tmate.sock
  local _tmate=/usr/local/bin/tmate

  if [ -z "$@" ]; then
    $_tmate -S $_sock
  else
    case $@ in
    p|print|ssh|url)
      $_tmate -S $_sock display -p '#{tmate_ssh}';;
    ro|printro|sshro|rourl|urlro|rossh)
      $_tmate -S $_sock display -p '#{tmate_ssh_ro}';;
    *)
      $_tmate -S $_sock
    esac
  fi
}

# Create a new directory and enter it
function mkd() {
    mkdir -p "$@" && cd "$@"
}

# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
function tre() {
    tree -aC -I '.git' --dirsfirst "$@" | less -FRNX
}

# Get colors in manual pages
function man() {
    env \
        LESS_TERMCAP_mb=$(printf "\e[1;31m") \
        LESS_TERMCAP_md=$(printf "\e[1;31m") \
        LESS_TERMCAP_me=$(printf "\e[0m") \
        LESS_TERMCAP_se=$(printf "\e[0m") \
        LESS_TERMCAP_so=$(printf "\e[1;44;33m") \
        LESS_TERMCAP_ue=$(printf "\e[0m") \
        LESS_TERMCAP_us=$(printf "\e[1;32m") \
        man "$@"
}

# go to a folder easily in your gopath
function gogo(){
    local d=$1
    local gopath=$(go env GOPATH)

    if [[ -z $d ]]; then
        echo "You need to specify a project name."
        return 1
    fi

    local _path="$(/usr/bin/find "${gopath}/src" -iname "$d" -type d | awk '{print length, $0;}' | sort -n | awk '{print $2}' | xargs | awk '{print $1}')"
    if [[ -z $_path ]]; then
        echo "Could not find a directory named $d in ${gopath}"
        echo "Maybe you need to 'go get' it ;)"
        return 1
    fi

    cd "$_path"
}

# because some systems need this in /etc/bashrc
function shopt {
  bash -lc "shopt $@"
}
# vim: ft=sh:
